// Модуль: ws64_rls_exp
// Описание: Правила экспорта (Выгрузки) объектов
// Автор: Валерий
// Дата создания: 2025-03-16  
// Версия: v1.0
// Зависимости:
//	Лог — модуль для ведения журнала операций (Обработки.ws64_log)

#Область библиотеки_экспорт 
Перем Лог Экспорт;	// для ведения журнала операций
// Перем ФС Экспорт; // Будет использовано для работы с файловой системой обмена
#КонецОбласти   

#Область библиотеки 
 // Перем Фрм; // Ссылка на общий модуль форматов ws64_frm_КлиентСервер
#КонецОбласти

#Область переменные_экспорт
//Входящие данные
Перем УзелПлана	Экспорт; 				// Узел плана обмена
Перем МассивОбъектовМетаданных Экспорт; // Массив объектов метаданных
Перем МассивСсылок Экспорт;				// Массив ссылок на объекты
Перем УровеньПодчинения Экспорт;		// Ограничение уровня выгрузки подчиненных объектов
Перем РегистраторОстатков Экспорт;		// Ссылка на документ регистратор остатков
Перем МассивРегистровОстатков Экспорт;	// Массив объектов метаданных регистров для выгрузки остатков
Перем ДатаНачалаИзменений Экспорт; 		// Дата начала выгрузки документов

// Результат
Перем Правила Экспорт;					// Соответствие, где ключ — тип, а значение — структура правил для этого типа
Перем ПорядокОбработкиПравил Экспорт;	// Массив типов объектов, определяющий последовательность их обработки
Перем Типы Экспорт; 					// Структура, где ключ — индекс типа, а значение — строковое представление типа
#КонецОбласти


#Область переменные_внутренние 

Перем ОчередьТипов;			// Очередь типов объектов для обработки
Перем ОчередьТиповОткрыта;	// Признак того, что очередь типов открыта для добавления
#КонецОбласти

#Область Конструкторы

Процедура ЗначенияПоУмолчанию()
	
	Лог = Обработки.ws64_log.Создать();
	
	УзелПлана					= Неопределено;
	МассивОбъектовМетаданных	= Новый Массив;
	МассивСсылок				= Новый Массив;
	УровеньПодчинения 			= 0;
	РегистраторОстатков			= Неопределено;
	МассивРегистровОстатков    = Новый Массив;
	УровеньПодчинения 			= Новый Массив;
	УровеньПодчинения_открыта	= Ложь;
	ДатаНачалаИзменений 		= Дата(1,1,1);
	
	//Типы выгружаемых ссылок и их реквизитов 
	//на их основании заполняется структура ТипыПакета для выгрузки получателю
	//Пример заполнения
	//Типы.Вставить(Тип("СправочникСсылка.Номенклатура"),Истина);
	
	Типы = Новый Структура;
	
КонецПроцедуры
Процедура Инициализация() Экспорт
	
	УровеньПодчинения_заполнить();
	Правила_заполнить();
	
КонецПроцедуры
Процедура Сброс() Экспорт
	ЗначенияПоУмолчанию();
КонецПроцедуры
#КонецОбласти

#Область Служебные_процедуры_функции             

// В зависимости от входящих параметров определим 
// массив типов являющийся персечением типов всех параметров
// а так же очередь обработки этих типов  
// устанавливаем флаг очередьоткрыта 
// для разрешения добавления типов в очередь 
Процедура УровеньПодчинения_заполнить()
	ОчередьТипов = Новый Массив;
	
	Если ЗначениеЗаполнено(РегистраторОстатков) Тогда
		Если ДатаНачалаИзменений <= РегистраторОстатков.Дата Тогда
			Дата_Начала_Изменений = РегистраторОстатков.Дата;
			ОчередьТипов.Добавить(ТипЗнч(РегистраторОстатков));
			Для Каждого Э Из МассивРегистровОстатков Цикл 
				ОчередьТипов.Добавить(ТипОбъектаМетаданных(Э));
			КонецЦикла;        
		КонецЕсли;
	КонецЕсли;
	
	Т = Новый ТаблицаЗначений;
	Т.Колонки.Добавить("Т"); // тип элемента входящих данных
	Т.Колонки.Добавить("В"); // для предотвращения задвоений
	Т.Колонки.Добавить("К"); // кол-во

	Если //вариант 1
		Истина Тогда
		ВР1 = 0;
		Если ЗначениеЗаполнено(УзелПлана) Тогда
			Для Каждого Э Из УзелПлана.Метаданные().Состав Цикл
				С = Т.Добавить();
				С.Т = ТипОбъектаМетаданных(Э.Метаданные.ПолноеИмя());
				С.В = 1;
				С.К = 1;
				ВР1 = 1;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если //вариант 2
		Истина Тогда
		
		ВР2 = 0;
		Если ЗначениеЗаполнено(МассивОбъектовМетаданных)	Тогда
			Для Каждого Э Из МассивОбъектовМетаданных Цикл 
				С = Т.Добавить();
				С.Т = ТипОбъектаМетаданных(Э);
				С.В = 2;
				С.К = 1;
				ВР2 = 1;
				
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Если //вариант 3
		Истина Тогда
		
		ВР3=0;
		Если ЗначениеЗаполнено(МассивСсылок)	Тогда  
			Для Каждого Э Из МассивСсылок Цикл 
				Если ЗначениеЗаполнено(Э) Тогда
					С = Т.Добавить();
					С.Т = ТипЗнч(Э);
					С.В = 3;
					С.К = 1;
					
					ВР3 = 1;
					
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Т.Свернуть("Т,В,К"); // Удаление дублей в кажом варианте условий 
	Т.Свернуть("Т","К"); // Количество Типов
	
	// В план и очередь добаляются только те типы
	// которые есть в каждом непустом элементе 
	Варианты = ВР1 + ВР2 + ВР3;
	
	Для Каждого С ИЗ Т Цикл
		Если С.К = Варианты Тогда 
			ОчередьТипов.Добавить(Э.Т);
		КонецЕсли;
	КонецЦикла;

	ОчередьТиповОткрыта = УровеньПодчинения > 0;

КонецПроцедуры

Процедура Правила_заполнить()

	Правила = Новый Соответствие;
	ПорядокОбработкиПравил = Новый Массив;
	
	Текущий_уровень		= 0;
	Порядковый_номер	= 0;
	
	//Для определения и ограничения уровней ссылок используем 
	//обратный счетчик количества элементов на уровне
	Размер_уровня	= ОчередьТипов.Количество();	
	
	Пока ОчередьТипов.Количество() > 0 Цикл
		
		Т = ОчередьТипов[0];       
		
		Правило(Т,Порядковый_номер);
		
		//Удалим из очереди обработанный тип
		ОчередьТипов.Удалить(0);
		
		//Увеличим порядковый номер типа
		Порядковый_номер	= Порядковый_номер + 1;
		Размер_уровня		= Размер_уровня - 1;
		
		Если Размер_уровня = 0 Тогда                             
			//Обпределим количество на следующем уровне
			Размер_уровня = ОчередьТипов.Количество();	
			//Повысим_уровень
			Текущий_уровень = Текущий_уровень + 1;
			Если Текущий_уровень > УровеньПодчинения Тогда
				// При превышении уровня ссылок закроем очередь
				ОчередьТиповОткрыта = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	
    // определим порядок обработки
	Т = Новый ТаблицаЗначений;
	Т.Колонки.Добавить("Т");
	Т.Колонки.Добавить("У");
	Т.Колонки.Добавить("П");
	
	Для Каждого П ИЗ Правила Цикл
		С = Т.Добавить();
		С.Т = П.Ключ;
		С.У = П.Значение.Уровень;
		С.П = П.Значение.Порядок;
	КонецЦикла;
	
	Т.Сортировать("У Убыв, П Убыв"); 
	
	Правила_порядок_обработки = Т.ВыгрузитьКолонку("Т");
	
	//Определим представление типа согласно порядку обработки
	
	Для К = 0 По Правила_порядок_обработки.ВГраница() Цикл
		
		Т = Правила_порядок_обработки[К];
		Правила[Т].Представление_типа = "Т"+ Формат(К, "ЧН=; ЧГ=");
		
	КонецЦикла;
	
КонецПроцедуры 
Процедура Правило(Т,Номер)
	
	П = Правила[Т];
	Если ЗначениеЗаполнено(П) Тогда
		П.Порядок = Номер;
		Возврат;
	КонецЕсли;  
	
	П = Новый Структура;
	П.Вставить("Порядок",Номер);
	П.Вставить("Имя",					XMLТип(Т).ИмяТипа);  
	П.Вставить("Мета",					Метаданные.НайтиПоТипу(Т));  
	П.Вставить("Представление_типа");	//Представление типа для файла выгрузки Например "Т15"
	П.Вставить("Вид");
	П.Вставить("Уровень");  

	Если Правило_вид_уровень_определены(П) Тогда
		Возврат;
	КонецЕсли;   

    Правило_очередь(П);
	
	// ТекстЗапроса по метаданным
	П.Вставить("ЗапросМТД",	Запрос_МТД(П)); 
	// ТекстЗапроса по метаданным с фильтрацией по массиву ссылок
	П.Вставить("ЗапросСЛК",	Новый Структура); 
	// ТекстЗапроса по метаданным регистров для фиксации остатков
	П.Вставить("ЗапросОСТ",	Новый Структура); 

	// Фильтр ссылок для запроса по метаданным с фильтрацией
	П.Вставить("Ссылка",	Новый Соответствие); //Ссылки Новые (отрабатываются с иерархией)
	П.Вставить("Повтор",	Новый Соответствие); //Ссылки Повторы должны пропускаться 
	
	Правила.Вставить(Т,П);	
КонецПроцедуры
Функция	  Правило_вид_уровень_определены(П) 
	
	П.Вид = "-";	
	Если П.Мета = Неопределено 									Тогда П.Уровень = 0; Возврат Ложь; КонецЕсли;
	
	П.Вид = ВидОбъектаМетаданных(П.Мета);  
	
	Если Метаданные.Перечисления.Содержит(П.Мета)				Тогда П.Уровень = 1; Возврат Ложь;	КонецЕсли;  
	

	
	// запретим виды метаданных не входящих в состав узла если Узел определен 
	Если ЗначениеЗаполнено(УзелПлана) Тогда
		К = УзелПлана.Метаданные().Состав.Найти(П.Мета);
		Если К = Неопределено Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если Метаданные.ПланыВидовХарактеристик.Содержит(П.Мета)	Тогда П.Уровень = 2; Возврат Ложь; КонецЕсли; 
	Если Метаданные.Справочники.Содержит(П.Мета)				Тогда П.Уровень = 3; Возврат Ложь; КонецЕсли;
	Если Метаданные.Константы.Содержит(П.Мета)					Тогда П.Уровень = 5; Возврат Ложь; КонецЕсли;
	
	Если Метаданные.РегистрыСведений.Содержит(П.Мета)           Тогда П.Уровень = 6;
		Если НЕ П.Мета.ПериодичностьРегистраСведений = 
			Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.ПозицияРегистратора
			Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЕсли; 

	Если ЗначениеЗаполнено(РегистраторОстатков) Тогда
		Если Метаданные.РегистрыСведений.Содержит(П.Мета)           Тогда П.Уровень = 6;
			Если П.Мета.ПериодичностьРегистраСведений = 
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.ПозицияРегистратора
				Тогда
				Возврат Ложь;
			КонецЕсли; 
		КонецЕсли; 
		Если Метаданные.РегистрыНакопления.Содержит(П.Мета)			Тогда П.Уровень = 7; Возврат Ложь; КонецЕсли;
	КонецЕсли;

	Если Метаданные.Документы.Содержит(П.Мета)					Тогда П.Уровень = 4; Возврат Ложь; КонецЕсли;

	Возврат Истина;
	
КонецФункции
Процедура Правило_очередь(П)
	
	М = П.Мета;
	
	Если Найти("ПланВидовХарактеристик",П.Вид)>0 Тогда
		Правило_очередь_добавить_типы(М.Тип.Типы());
	КонецЕсли; 
	Если Найти("ПланВидовХарактеристик_Документ_Справочник",П.Вид)>0 Тогда
		Для Каждого Р ИЗ М.СтандартныеРеквизиты Цикл
			Правило_очередь_добавить_типы(Р.Тип.Типы());
		КонецЦикла;   
		Для Каждого Р ИЗ М.Реквизиты Цикл
			Правило_очередь_добавить_типы(Р.Тип.Типы());
		КонецЦикла;    
		Для Каждого ТЧ ИЗ М.ТабличныеЧасти Цикл
			Для Каждого Р ИЗ ТЧ.Реквизиты Цикл
				Правило_очередь_добавить_типы(Р.Тип.Типы());
			КонецЦикла;   
		КонецЦикла; 
	КонецЕсли;
	Если Найти("Перечисление",П.Вид)>0 Тогда     
		Для Каждого Р ИЗ М.СтандартныеРеквизиты Цикл
			Правило_очередь_добавить_типы(Р.Тип.Типы());
		КонецЦикла;   
	КонецЕсли;	
    Если Найти("Константа",П.Вид)>0 Тогда
	//TODO	
	КонецЕсли;	
	Если Найти("РегистрСведений",П.Вид)>0 Тогда
		Для Каждого Р ИЗ М.Измерения Цикл
			Правило_очередь_добавить_типы(Р.Тип.Типы());
		КонецЦикла; 
		Для Каждого Р ИЗ М.Ресурсы Цикл
			Правило_очередь_добавить_типы(Р.Тип.Типы());   
		КонецЦикла; 
		Для Каждого Р ИЗ М.СтандартныеРеквизиты Цикл
			Правило_очередь_добавить_типы(Р.Тип.Типы());
		КонецЦикла;  
	КонецЕсли;	
	Если Найти("РегистрНакопления",П.Вид)>0 Тогда
		//Регистры накопления использутся только для переноса остатков
		//в остальных случаях движения формируются переносимыми документами
		//поэтому достаочно Измерений и ресурсов
		//ревкизиты и стандартные реквизиты переноситься не будут
		
		//Для Каждого Р ИЗ М.СтандартныеРеквизиты Цикл
		//	Правило_очередь_добавить_типы(Р.Тип.Типы());
		//КонецЦикла;  
		Для Каждого Р ИЗ М.Измерения Цикл
			Правило_очередь_добавить_типы(Р.Тип.Типы());
		КонецЦикла; 
		Для Каждого Р ИЗ М.Ресурсы Цикл
			Правило_очередь_добавить_типы(Р.Тип.Типы());   
		КонецЦикла; 
		//Для Каждого Р ИЗ М.Реквизиты Цикл
		//	Правило_очередь_добавить_типы(Р.Тип.Типы());   
		//КонецЦикла; 
	КонецЕсли;	
	
КонецПроцедуры
Процедура Правило_очередь_добавить_типы(М)
	
	Если ОчередьТиповОткрыта Тогда
		Для Каждого Т ИЗ М Цикл     
			УровеньПодчинения.Добавить(Т);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Функция Запрос_МТД(П)
	Если П.Мета = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	//Если П.Вид = 
	
	
КонецФункции


//Методы
Функция ТипОбъектаМетаданных(Знач МТ) 	Экспорт 
	МТ = СтрЗаменить(МТ,"Константа.",				"КонстантаМенеджер.");
	МТ = СтрЗаменить(МТ,"Справочник.",				"СправочникСсылка.");
	МТ = СтрЗаменить(МТ,"ПланВидовХарактеристик.",	"ПланВидовХарактеристикСсылка.");
	МТ = СтрЗаменить(МТ,"Документ.",				"ДокументСсылка.");
	МТ = СтрЗаменить(МТ,"РегистрСведений.",			"РегистрСведенийНаборЗаписей.");
	МТ = СтрЗаменить(МТ,"РегистрНакопления.",		"РегистрНакопленияНаборЗаписей."); 
	МТ = СтрЗаменить(МТ,"Задача.",					"ЗадачаСсылка."); 
	МТ = СтрЗаменить(МТ,"Перечисление.",			"ПеречислениеСсылка."); 
	  
	МТ = СтрЗаменить(МТ,".",Символы.ПС);
	Вид = СтрПолучитьСтроку(МТ,1);
	Имя = СтрПолучитьСтроку(МТ,2);  
	Возврат Тип(Вид+"."+Имя);
КонецФункции
Функция ВидОбъектаМетаданных(МТ)
	Имя = МТ.ПолноеИмя();
	Имя = СтрЗаменить(МТ,".",Символы.ПС);
	Вид = СтрПолучитьСтроку(Имя,1);
	Возврат Вид;
КонецФункции	
#КонецОбласти
//Основная программа выполняется при создании объекта
ЗначенияПоУмолчанию(); 
